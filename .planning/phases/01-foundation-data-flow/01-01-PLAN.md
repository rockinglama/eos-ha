---
phase: 01-foundation-data-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - custom_components/eos_ha/manifest.json
  - custom_components/eos_ha/hacs.json
  - custom_components/eos_ha/const.py
  - custom_components/eos_ha/config_flow.py
  - custom_components/eos_ha/strings.json
  - custom_components/eos_ha/translations/en.json
autonomous: true

must_haves:
  truths:
    - "User can see EOS HA in the Add Integration UI after placing files in custom_components"
    - "User can complete 3-step Config Flow: EOS URL → entity selection → battery parameters"
    - "Config Flow rejects setup if EOS server is unreachable or returns unexpected response"
    - "Config Flow pulls lat/lon from HA home zone automatically"
    - "Battery capacity is entered in kWh (not Wh) with sensible defaults"
  artifacts:
    - path: "custom_components/eos_ha/manifest.json"
      provides: "Integration metadata for HA discovery"
      contains: "\"domain\": \"eos_ha\""
    - path: "custom_components/eos_ha/hacs.json"
      provides: "HACS compatibility metadata"
      contains: "\"name\": \"EOS HA\""
    - path: "custom_components/eos_ha/const.py"
      provides: "Shared constants for all modules"
      contains: "DOMAIN"
    - path: "custom_components/eos_ha/config_flow.py"
      provides: "3-step Config Flow with EOS validation"
      contains: "async_step_user"
    - path: "custom_components/eos_ha/strings.json"
      provides: "UI strings for Config Flow"
      contains: "\"step\""
    - path: "custom_components/eos_ha/translations/en.json"
      provides: "English translations matching strings.json"
      contains: "\"step\""
  key_links:
    - from: "custom_components/eos_ha/config_flow.py"
      to: "custom_components/eos_ha/const.py"
      via: "imports DOMAIN and config keys"
      pattern: "from .const import"
    - from: "custom_components/eos_ha/config_flow.py"
      to: "EOS /v1/health endpoint"
      via: "aiohttp GET for server validation"
      pattern: "v1/health"
---

<objective>
Create the HACS-compatible integration skeleton and implement the 3-step Config Flow that collects EOS server URL (with validation), HA entity selections, and battery parameters.

Purpose: Establish the integration foundation so users can install via HACS and configure the integration through HA's UI. This is the entry point for all subsequent functionality.
Output: Working Config Flow that creates a config entry with all data needed for the optimization cycle.
</objective>

<execution_context>
@/Users/idueck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/idueck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-data-flow/01-RESEARCH.md
@.planning/phases/01-foundation-data-flow/01-CONTEXT.md
@src/interfaces/optimization_backends/optimization_backend_eos.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HACS integration skeleton and constants</name>
  <files>
    custom_components/eos_ha/__init__.py
    custom_components/eos_ha/manifest.json
    custom_components/eos_ha/hacs.json
    custom_components/eos_ha/const.py
  </files>
  <action>
Create the directory structure `custom_components/eos_ha/` with these files:

**manifest.json**: Integration manifest with:
- `"domain": "eos_ha"`
- `"name": "EOS HA"`
- `"version": "0.1.0"`
- `"codeowners": []`
- `"config_flow": true`
- `"dependencies": []`
- `"documentation": "https://github.com/rockinglama/eos-ha"`
- `"iot_class": "local_polling"`
- `"requirements": []` (aiohttp is built into HA; no external deps needed)

**hacs.json**: HACS metadata with:
- `"name": "EOS HA"`
- `"render_readme": true`

**const.py**: All shared constants. Include:
- `DOMAIN = "eos_ha"`
- `DEFAULT_SCAN_INTERVAL = 300` (5 minutes in seconds)
- `AKKUDOKTOR_API_URL = "https://api.akkudoktor.net/forecast"`
- `PV_FORECAST_CACHE_HOURS = 6`
- Config key constants: `CONF_EOS_URL`, `CONF_PRICE_ENTITY`, `CONF_SOC_ENTITY`, `CONF_CONSUMPTION_ENTITY`, `CONF_BATTERY_CAPACITY` (kWh), `CONF_MAX_CHARGE_POWER` (W), `CONF_MIN_SOC`, `CONF_MAX_SOC`, `CONF_INVERTER_POWER` (W)
- Default battery values (Claude's discretion — sensible defaults for common home batteries):
  - `DEFAULT_BATTERY_CAPACITY = 10.0` (kWh — common mid-range)
  - `DEFAULT_MAX_CHARGE_POWER = 5000` (W)
  - `DEFAULT_MIN_SOC = 10` (percent)
  - `DEFAULT_MAX_SOC = 90` (percent)
  - `DEFAULT_INVERTER_POWER = 10000` (W)

**__init__.py**: Minimal placeholder with:
- `PLATFORMS = ["sensor"]`
- Stub `async_setup_entry` and `async_unload_entry` that just return True (will be completed in Plan 02)
- Import DOMAIN from const
  </action>
  <verify>
Run: `python -c "import json; d=json.load(open('custom_components/eos_ha/manifest.json')); assert d['domain']=='eos_ha'; assert d['config_flow']==True; print('manifest OK')"` and
`python -c "import ast; ast.parse(open('custom_components/eos_ha/const.py').read()); print('const.py OK')"`
  </verify>
  <done>
manifest.json is valid JSON with config_flow=true, hacs.json exists, const.py defines DOMAIN and all config key constants, __init__.py has stub setup functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement 3-step Config Flow with EOS validation and UI strings</name>
  <files>
    custom_components/eos_ha/config_flow.py
    custom_components/eos_ha/strings.json
    custom_components/eos_ha/translations/en.json
  </files>
  <action>
Create the Config Flow implementation per user's locked decisions.

**config_flow.py**: Implement `EOSConnectConfigFlow(config_entries.ConfigFlow, domain=DOMAIN)` with `VERSION = 1`:

**Step 1: `async_step_user`** — EOS Server URL:
- Show form with single field: EOS server URL (string, required)
- On submission, validate EOS server:
  - Create temporary `aiohttp.ClientSession` (use `aiohttp.ClientTimeout(total=10)`)
  - GET `{url}/v1/health`
  - Check response: status 200, JSON body has `"status": "alive"` (see `optimization_backend_eos.py` line 276 for format)
  - Store EOS version from response `data.get("version", "unknown")` in flow data
  - On success: store URL and proceed to `async_step_entities`
  - On `aiohttp.ClientError` or `asyncio.TimeoutError`: show error `"cannot_connect"`
  - On unexpected response (not 200 or status != "alive"): show error `"invalid_response"`
  - Close the temporary session in a finally block
- Also retrieve lat/lon from HA home zone: `self.hass.config.latitude` and `self.hass.config.longitude` — these are available directly on the HA config object. If either is None or 0, abort with reason `"no_home_location"`.

**Step 2: `async_step_entities`** — Entity Selection:
- Show form with 3 entity selectors (all required):
  - Price entity: `selector.EntitySelector(selector.EntitySelectorConfig(domain="sensor"))` — note: don't filter by device_class="monetary" as Tibber entities don't always use this class. Show all sensor entities.
  - SOC entity: `selector.EntitySelector(selector.EntitySelectorConfig(domain="sensor", device_class="battery"))` — highlights battery sensors
  - Consumption entity: `selector.EntitySelector(selector.EntitySelectorConfig(domain="sensor"))` — show all sensors, user picks their load/consumption sensor
- On submission: store entity IDs and proceed to `async_step_battery`

**Step 3: `async_step_battery`** — Battery Parameters:
- Show form with pre-filled defaults (from const.py):
  - Battery capacity (kWh): `vol.Required(CONF_BATTERY_CAPACITY, default=DEFAULT_BATTERY_CAPACITY)` with `vol.All(vol.Coerce(float), vol.Range(min=0.5, max=200.0))`
  - Max charge power (W): `vol.Required(CONF_MAX_CHARGE_POWER, default=DEFAULT_MAX_CHARGE_POWER)` with `vol.All(vol.Coerce(int), vol.Range(min=100, max=50000))`
  - Min SOC (%): `vol.Required(CONF_MIN_SOC, default=DEFAULT_MIN_SOC)` with `vol.All(vol.Coerce(int), vol.Range(min=0, max=100))`
  - Max SOC (%): `vol.Required(CONF_MAX_SOC, default=DEFAULT_MAX_SOC)` with `vol.All(vol.Coerce(int), vol.Range(min=0, max=100))`
  - Inverter power (W): `vol.Required(CONF_INVERTER_POWER, default=DEFAULT_INVERTER_POWER)` with `vol.All(vol.Coerce(int), vol.Range(min=100, max=100000))`
- On submission: merge all data and create config entry with `self.async_create_entry(title="EOS HA", data=self.data)`
- The self.data dict accumulates across steps and should include: EOS URL, lat, lon, eos_version, 3 entity IDs, 5 battery params

Use `self.async_set_unique_id(DOMAIN)` in `async_step_user` to prevent duplicate entries, with `self._abort_if_unique_id_configured()`.

**strings.json and translations/en.json**: Both files must have identical structure. Include:
- `config.step.user.title`: "EOS HA"
- `config.step.user.description`: "Enter the URL of your EOS optimization server."
- `config.step.user.data.eos_url`: "EOS Server URL"
- `config.step.entities.title`: "Entity Selection"
- `config.step.entities.description`: "Select the Home Assistant entities that provide energy data."
- `config.step.entities.data.price_entity`: "Electricity Price Entity"
- `config.step.entities.data.soc_entity`: "Battery State of Charge Entity"
- `config.step.entities.data.consumption_entity`: "Consumption/Load Entity"
- `config.step.battery.title`: "Battery Parameters"
- `config.step.battery.description`: "Configure your battery system parameters."
- `config.step.battery.data.battery_capacity`: "Battery Capacity (kWh)"
- `config.step.battery.data.max_charge_power`: "Max Charge Power (W)"
- `config.step.battery.data.min_soc`: "Minimum SOC (%)"
- `config.step.battery.data.max_soc`: "Maximum SOC (%)"
- `config.step.battery.data.inverter_power`: "Inverter Power (W)"
- `config.error.cannot_connect`: "Cannot connect to EOS server. Check the URL and ensure the server is running."
- `config.error.invalid_response`: "Connected but received unexpected response. Ensure this is an EOS server."
- `config.error.timeout`: "Connection timed out. Check the URL and network."
- `config.abort.already_configured`: "EOS HA is already configured."
- `config.abort.no_home_location`: "Home location not configured in Home Assistant. Set your home location in Settings > System > General."
  </action>
  <verify>
Run: `python -c "import ast; tree=ast.parse(open('custom_components/eos_ha/config_flow.py').read()); classes=[n.name for n in ast.walk(tree) if isinstance(n, ast.ClassDef)]; assert 'EOSConnectConfigFlow' in classes; print('config_flow.py OK')"` and
`python -c "import json; s=json.load(open('custom_components/eos_ha/strings.json')); assert 'config' in s; assert 'step' in s['config']; assert 'user' in s['config']['step']; assert 'entities' in s['config']['step']; assert 'battery' in s['config']['step']; print('strings.json OK')"` and
`python -c "import json; t=json.load(open('custom_components/eos_ha/translations/en.json')); assert 'config' in t; print('translations OK')"`
  </verify>
  <done>
Config Flow has 3 steps: user (EOS URL + validation via /v1/health), entities (3 entity selectors), battery (5 parameters with defaults in kWh). Location pulled from HA config. strings.json and translations/en.json have matching structure with all labels, errors, and abort reasons.
  </done>
</task>

</tasks>

<verification>
1. Directory structure exists: `custom_components/eos_ha/` with all 7 files
2. `manifest.json` is valid JSON with `config_flow: true` and `domain: eos_ha`
3. `hacs.json` is valid JSON with `name: EOS HA`
4. `const.py` defines DOMAIN, all CONF_* keys, all DEFAULT_* values
5. `config_flow.py` defines EOSConnectConfigFlow with async_step_user, async_step_entities, async_step_battery
6. Config Flow validates EOS server via /v1/health endpoint (checks status="alive")
7. Config Flow retrieves home location from self.hass.config (not user input)
8. `strings.json` and `translations/en.json` have identical structure with all 3 steps
9. All Python files pass `ast.parse()` (valid syntax)
</verification>

<success_criteria>
- All 7 files exist with valid content
- Config Flow class inherits from ConfigFlow with domain=DOMAIN
- 3 steps implemented: user → entities → battery
- EOS validation checks /v1/health for status "alive"
- Entity selectors use EntitySelector with appropriate device_class hints
- Battery capacity defaults to 10.0 kWh (not Wh)
- Location comes from HA config, not user input
- strings.json and translations/en.json are consistent
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-data-flow/01-01-SUMMARY.md`
</output>
